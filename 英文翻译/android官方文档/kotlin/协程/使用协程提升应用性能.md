

# 使用协程提升应用性能

* https://developer.android.com/kotlin/coroutines/coroutines-adv

[TOC]

## 管理长时间运行任务

### 概述
* 协程通过在常规函数中增加两个操作符来处理长时间运行任务
    * suspend：暂停当前协程的执行，并保存所有的本地变量
    * resume：从暂停的地方继续开始执行一个被挂起的协程
* 只能从另一个suspend函数中调用suspend函数
* 使用协程生成器(像launch)来启动一个新的协程

### 示例
```kotlin
suspend fun fetchDocs() {                             // Dispatchers.Main
    val result = get("https://developer.android.com") // Dispatchers.IO for `get`
    show(result)                                      // Dispatchers.Main
}

suspend fun get(url: String) = withContext(Dispatchers.IO) { /* ... */ }
```
* 例子中get()函数依然运行在主线程中，但是在启动网络请求前该函数会挂起协程
* 当网络请求完成后，get()会恢复被挂起的协程。这会代替回调来通知主线程


### 堆栈帧
* Kotlin使用堆栈帧来管理函数运行的位置和局部变量
* 当挂起一个协程时，当前堆栈帧会被拷贝并保存起来
* 当恢复一个协程时，堆栈帧会被拷贝回保存的地方，函数会重新开始运行
* 尽管代码看起来像一个普通的序列阻塞请求，协程会确保网络请求避免阻塞主线程



## 主线程安全协程

### 概述
* Kotlin协程使用分发器来决定哪个线程浙来运行协程
* 为了在主线程外运行代码，你可以告知Kotlin协程在默认、IO分发器中执行代码
* 在Kotlin中，所有的协程都必须运行在一个分发器上，就算是运行在主线程上
* 协程可以挂起自己，分发器会负责恢复这些协程

### 分发器类型
* **Dispatchers.Mian**：该分发器用于在主线程中运行协程，只能与界面的交互和执行一些快速的操作
    * 例子：调用suspend函数，运行andorid界面框架操作，更新LiveData对象
* **Dispatchers.IO**：该分发器对于在主线程外执行磁盘、网络IO操作进行了优化
    * 例子：使用Room组件，读写文件、运行网络操作
* **Dispatchers.Default**：该分发器对于在主线程外执行CPU密集操作进行了优化
    * 例子：排序列表，解析JSON


### 示例
```kotlin
suspend fun fetchDocs() {                      // Dispatchers.Main
    val result = get("developer.android.com")  // Dispatchers.Main
    show(result)                               // Dispatchers.Main
}

suspend fun get(url: String) =                 // Dispatchers.Main
    withContext(Dispatchers.IO) {              // Dispatchers.IO (main-safety block)
        /* 在这里执行网络IO操作 */                // Dispatchers.IO (main-safety block)
    }                                          // Dispatchers.Main
}
```
* 在get()中，调用withContext(Dispatchers.IO)来创建一个运行在IO线程池中的代码块
    * 其中的任何代码都会使用IO分发器执行
    * withContext()函数本身就是一个suspend函数，所以get()也必须是suspend函数


#### 分发线程
* 使用协程，你可以以更细致的方式来分发线程
* withContext()可以让你在任何一行中控制线程池，并且不会引入回退
    * 你可以应用到非常小的函数，像读取数据库、执行网络请求
* 一个好的实践就是使用withContext()来确保每个函数都是主线程安全的（意味着你可以在主线程中调用这些函数）
    * 这样调用这就不需要在考虑需要使用什么线程来执行这些函数

#### 挂起和恢复
* 例子汇总fetchDocs()在主线程中执行，可以安全的调用get()，该函数在后台线程中执行网络请求
* 因为协程支持suspend和resume，主线程中的协程会在withContext()代码块运行结束后，恢复执行并从get()中获取到结果

#### 要点
* suspend并不会告诉Kotlin在后台线程中运行函数
* suspend函数正常都在主线程中运行，会在主线程中启动协程
* 当你需要主线程安全时，你需要在suspend函数内部使用withContext()


### withContext()性能
