

# 协程介绍

* https://developer.android.com/kotlin/coroutines

[TOC]


## 概述
* 协程是一种并发的设计模式，可以在android中使用来简化异步执行的代码
* Coroutines是Kotlin 1.3中加入的功能
* 在android开发中，协程用于管理那些会阻塞主线程的长时间运行的任务
* 使用协程的专业开发者中有50%的人报告说协程提供了开发效率


## 特征
协程是我们推荐的异步开发解决方案
* **轻量级**：通过suspension可以在一个线程汇总运行大量的协程
    * suspend不会阻塞线程
    * 在支持大量并发操作上，suspend比阻塞会节省大量的内存
* **低内存泄漏**：使用 结构化并发 在一个作用域中执行操作
* **内建的取消操作**：取消操作会跟随运行的协程自动执行
* **Jetpack整合**：大量的Jetpack库都完整的支持了协程
    * 一些库还提供了自己的协程作用域，可以用于 结构化并发


## 示例说明


## 添加依赖
* build.gradle示例
    ```groovy
    dependencies {
        implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9'
    }
    ```



## 在后台线程执行操作

### 问题
* 在主线程中执行网络请求会导致等待、阻塞，直到接收到响应数据
* 当主线程被阻塞后，系统将无法调用onDraw()，导致我们的应用界面冻结和导致出现ANR对话框
* 为了更好的用户体验，需要在后台线程中执行这些操作


### 示例
#### Repository
```kotlin
sealed class Result<out R> {
    data class Success<out T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
}

class LoginRepository(private val responseParser: LoginResponseParser) {
    private const val loginUrl = "https://example.com/login"

    // 该函数会进行网络请，并阻塞当前线程
    fun makeLoginRequest(
        jsonBody: String
    ): Result<LoginResponse> {
        val url = URL(loginUrl)
        (url.openConnection() as? HttpURLConnection)?.run {
            requestMethod = "POST"
            setRequestProperty("Content-Type", "application/json; utf-8")
            setRequestProperty("Accept", "application/json")
            doOutput = true
            outputStream.write(jsonBody.toByteArray())
            return Result.Success(responseParser.parse(inputStream))
        }
        return Result.Error(Exception("Cannot open HttpURLConnection"))
    }
}
```
* Repository类，生成网络请求
* makeLoginRequest是一个同步函数会阻塞调用线程
* 使用Result类对网络响应进行建模

#### ViewModel同步调用
```kotlin
class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun login(username: String, token: String) {
        val jsonBody = "{ username: \"$username\", token: \"$token\"}"
        loginRepository.makeLoginRequest(jsonBody)
    }
}
```
* 当用户点击按键时，ViewModel触发网络请求
* LoginViewModel在触发网络请求时会阻塞UI线程
* 最简单的方案通常创建协程将操作移除主线程，在IO线程上执行网络请求

#### ViewModel异步调用
```kotlin
class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun login(username: String, token: String) {
        // 创建一个新协程，将操作移除UI线程
        viewModelScope.launch(Dispatchers.IO) {
            val jsonBody = "{ username: \"$username\", token: \"$token\"}"
            loginRepository.makeLoginRequest(jsonBody)
        }
    }
}
```

##### login函数的协程代码
* viewModelScope是一个包含在ViewModel KTX扩展中的预定义的CoroutineScope
    * 所有的线程都必须运行在一个作用域中
    * 一个CoroutineScope管理一个、多个相关的协程
* launch函数用于创建协程并将函数体分发到对应的分发器中运行
* Dispatchers.IO表明协程将在一个为IO操作保留的线程中被执行

##### login函数的执行过程
1. 应用在主线程从视图层调用login函数
1. launch创建协程，在独立线程中执行网络请求
1. 当协程运行时，login函数会继续执行并可能在网络请求结束之前返回，
    * 注意为了简单起见，忽略了网络响应


### 总结
* 当viewModelScope启动协程后，协程会在ViewModel的作用域中被执行
* 如果因为用户从当前界面导航出去而导致ViewModel被销毁
    * viewModelSope会自动取消，所有的运行中的协程也会被取消
* 该示例的一个问题就是任何makeLoginRequest的调用都需要显式地移出主线程执行



## 以主线程安全方式使用协程

### 概述
* 主线程安全函数是指该函数在主线程中执行时不会阻塞界面更新
* makeLoginRequest函数不是主线程安全的
* 通过withContext()函数可以将协程执行移到另一个线程中执行

### 示例
#### Repository
```kotlin
class LoginRepository(...) {
    ...
    suspend fun makeLoginRequest(
        jsonBody: String
    ): Result<LoginResponse> {

        // 移动协程到IO分发器中执行
        return withContext(Dispatchers.IO) {
            // 阻塞的网络请求代码
        }
    }
}
```
* withContext(Dispatchers.IO)会将协程移动到一个IO线程中执行
    * 可以使函数变成主线程安全，在需要时更新界面
* makeLoginRequest也使用suspend关键字进行了标记
    * 该关键字是Kotlin中用于增强函数，使其可以在协程中被调用

#### ViewModel
```kotlin
class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun login(username: String, token: String) {

        // 在UI线程中创建一个新的协程
        viewModelScope.launch {
            val jsonBody = "{ username: \"$username\", token: \"$token\"}"

            // 调用网络，执行会被挂起直到网络调用完成
            val result = loginRepository.makeLoginRequest(jsonBody)

            // 显示网络请求的结果给用户
            when (result) {
                is Result.Success<LoginResponse> -> // Happy path
                else -> // Show error in UI
            }
        }
    }
}
```
* 注意这里仍然需要创建协程，因为makeLoginRequest是一个suspend函数
    * 所有的suspend函数都必须在一个协程中被执行


#### 不同点
* launch不使用Dispatchers.IO参数
    * 所有viewModelScope中启动的协程都会运行在主线程中
* 现在网络请求的结果可以处理并显示成功、失败界面

#### login函数的执行过程
1. 应用在主线程从视图层调用login函数
1. launch创建一个协程在主线程中执行网络请求，协程开始执行
1. 在协程中调用loginRepository.makeLoginRequest()，会挂起协程的执行，直到makeLoginRequest()中的withContext代码块运行完成
1. 一旦withContext代码块执行完成，在login()中的协程会带着网络请求的结果继续执行




## 处理异常
* 可以使用Kotlin内建的异常机制来处理Repository抛出的异常

### 示例
```kotlin
class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun makeLoginRequest(username: String, token: String) {
        viewModelScope.launch {
            val jsonBody = "{ username: \"$username\", token: \"$token\"}"
            val result = try {
                loginRepository.makeLoginRequest(jsonBody)
            } catch(e: Exception) {
                Result.Error(Exception("Network request failed"))
            }
            when (result) {
                is Result.Success<LoginResponse> -> // Happy path
                else -> // Show error in UI
            }
        }
    }
}
```