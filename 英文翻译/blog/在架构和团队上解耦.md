

# 在架构和团队上解耦

* https://mikehadlow.blogspot.com/2018/11/decoupling-architecture-and-teams.html


## 概述
* 本文主要讨论在软件开发中，代码组织和开发人员社会组织之间的关系
* 我想讨论一下以下几个方面
    * 为什么软件和开发团队并不容易扩张
    * 可以从生物学和互联网中学习到什么
    * 为什么解耦软件和开发团队可以克服扩展遇到的问题
* 这些讨论都是基于我20年构建大型软件系统的经验
* 但是我对这本书《加速：构建和扩展高效率技术组织》影响深刻
    * 这本书提供了一些研究数据可以支持我在本文提出的一些论点，我强烈推荐你读一下


## 软件和开发团队不易扩展
* 一个常见的故事
* 产品的第一个版本，可能由一、两个开发人员开发出来，看起来非常简单
    * 只能提供有限的功能，但是开发速度非常快，能完全满足顾客的需求
    * 由于顾客经常和开发者直接沟通，所以两者的沟通非常通畅
    * 任何缺陷都能快速被修正，任何新特征都能快速地添加上
* 一段时间后，这个步伐变慢了，软件的2.0版本要花费比期望的更长的时间
    * bug更难修复了，新特征不在能够容易的被添加上了
    * 一个自然的解决方法就是加入新的开发者，但是每个加入团队的人员看上去都在降低生产效率
* 随着软件的老化和复杂性的增长，这种情况似乎在萎缩
* 在极端情况下，开发团队会发现需要花费巨大的开销来维护软件，这种情况看起来无法改变
* 这些就是就是扩展性的负面影响
    * 问题在于对这种情况的发生你无法不阻止
    * 这种情况太常见了，以至于成为了软件的一种自然属性

### 原因
* 为什么会这样，这里有两个原因：代码和团队。代码和团队都没有进行好的扩展

#### 代码耦合
* 随着代码基的变大，代码会变得让一个人无法了解全部的内容
* 存在一个人类固有的认知极限，对于一个人来说去维护一个小系统所有细节的心智模型是完全可能的
    * 一旦超过了一定的大小，该心智模型就会大到超越一个人的认知范围
    * 一旦团队人数超过五个人，对于一个人来说就无法及时的了解到系统各个部分是如何运行的了
* 当没有一个人能理解整个系统时，就会产生恐惧
* 对于一个完全的耦合的大系统而言，想要知道任何重大变更的影响是非常困难的
    * 因为变动的后果无法被局部化
    * 开发者学会了使用临时措施和重复代码为手段的最小化影响的工作方式，而不是识别出共性，创建抽象和泛化
    * 这些工作方式会导致系统进一步变的复杂，更有可能放大这些负面的趋势
    * 开发者对这些代码没有了拥有者的感觉，不会真正地去理解代码，极不情愿的去重构
    * 技术债务会不断增长
    * 在工作时会感觉到不开心和不满足，导致优秀人才的流失，那些更容易在其他地方找到工作的人会离开

#### 团队沟通
* 团队也不会扩展，随着团队的变大，沟通会越来越难
* 简单的公式： $ c = n(n-1)/2 $
    * n表示团队中人的数量
    * c表示团队中沟通渠道的数量
* 简单的表格
    | 团队中人的数量 | 沟通渠道的数量 |
    | --- | --- |
    |  1  |  0  |
    |  2  |  1  |
    |  5  |  10  |
    |  10  |  45  |
    |  100  |  4950  |
* 团队的沟通和协作的需求会随着人数的增加而几何性的上升
* 当一个单一的团队人数超过一定数量时，要保持一致的整体性是非常困难的
    * 人们自然而然的就会分裂成一些非正式的内部小组
    * 对等的沟通会变得非常困难，会自热而然地被新兴领导和从上至下的沟通所替换
    * 团队成员会从平等的利益相关者变成直接的工作者
    * 在责任扩散效应的驱动下，动机会受到影响，缺失所有权
* 管理者经常会在这个阶段进行干预，正式创建一些新团队，并使用管理机构来组织他们
* 但是无论是正式还是非正式，大型组织都很难保持员工的动机和积极参与


### 结论
* 一个典型现象就是责怪技术差的开发人员、以及对扩展问题的不良管理
    * 但是这是不公平的，扩展问题是成长中软件的一个自然属性
* 除非你尽早地发现问题、识别出挂点、努力工作缓和该问题，不然扩展问题就会经常出现
* 软件团队会不停地被创建，大量的软件也会不停地成长，大部分软件都是小规模的
    * 对于一个开发成功、不停成长中产品的团队而言，在大规模软件开发上没有经验是很正常的事情
    * 期待他们在刚出现扩展性问题的时候就能识别出拐点，并知道如何处理是不现实的